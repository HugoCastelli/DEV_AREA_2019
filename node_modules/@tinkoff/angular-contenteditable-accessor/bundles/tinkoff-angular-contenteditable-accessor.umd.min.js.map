{"version":3,"sources":["ng://@tinkoff/angular-contenteditable-accessor/lib/contenteditable-value-accessor.ts","ng://@tinkoff/angular-contenteditable-accessor/lib/module.ts"],"names":["ContenteditableValueAccessor","elementRef","renderer","_this","this","observer","MutationObserver","setTimeout","onChange","processValue","nativeElement","innerHTML","onTouched","prototype","ngAfterViewInit","observe","characterData","childList","subtree","ngOnDestroy","disconnect","onInput","onBlur","writeValue","value","setProperty","registerOnChange","registerOnTouched","setDisabledState","disabled","setAttribute","String","processed","trim","Directive","args","selector","providers","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","multi","ElementRef","decorators","type","Inject","Renderer2","HostListener","ContenteditableValueAccessorModule","NgModule","declarations","exports"],"mappings":"iZAmBA,IAAAA,EAAA,WAuCI,SAAAA,EACyCC,EACDC,GAFxC,IAAAC,EAAAC,KACyCA,KAAAH,WAAAA,EACDG,KAAAF,SAAAA,EAtBhCE,KAAAC,SAAW,IAAIC,iBAAgB,WACnCC,WAAU,WACNJ,EAAKK,SACDR,EAA6BS,aACzBN,EAAKF,WAAWS,cAAcC,gBAStCP,KAAAQ,UAAS,aAKTR,KAAAI,SAAQ,aAsGpB,OA5FIR,EAAAa,UAAAC,gBAAA,WACIV,KAAKC,SAASU,QAAQX,KAAKH,WAAWS,cAAe,CACjDM,eAAe,EACfC,WAAW,EACXC,SAAS,KAOjBlB,EAAAa,UAAAM,YAAA,WACIf,KAAKC,SAASe,cASlBpB,EAAAa,UAAAQ,QADA,WAEIjB,KAAKC,SAASe,aACdhB,KAAKI,SACDR,EAA6BS,aACzBL,KAAKH,WAAWS,cAAcC,aAS1CX,EAAAa,UAAAS,OADA,WAEIlB,KAAKQ,aAQTZ,EAAAa,UAAAU,WAAA,SAAWC,GACPpB,KAAKF,SAASuB,YACVrB,KAAKH,WAAWS,cAChB,YACAV,EAA6BS,aAAae,KASlDxB,EAAAa,UAAAa,iBAAA,SAAiBlB,GACbJ,KAAKI,SAAWA,GAQpBR,EAAAa,UAAAc,kBAAA,SAAkBf,GACdR,KAAKQ,UAAYA,GAQrBZ,EAAAa,UAAAe,iBAAA,SAAiBC,GACbzB,KAAKF,SAAS4B,aACV1B,KAAKH,WAAWS,cAChB,kBACAqB,QAAQF,KASD7B,EAAAS,aAAf,SAA4Be,OAClBQ,EAAYR,GAAS,GAE3B,MAA4B,SAArBQ,EAAUC,OAAoB,GAAKD,uBAzIjDE,EAAAA,UAASC,KAAA,CAAC,CACPC,SACI,iGACJC,UAAW,CACP,CACIC,QAASC,EAAAA,kBACTC,YAAaC,EAAAA,WAAU,WAAO,OAAAzC,IAC9B0C,OAAO,iDAvBfC,EAAAA,WAAUC,WAAA,CAAA,CAAAC,KAwDLC,EAAAA,OAAMX,KAAA,CAACQ,EAAAA,qBAnDZI,EAAAA,UAASH,WAAA,CAAA,CAAAC,KAoDJC,EAAAA,OAAMX,KAAA,CAACY,EAAAA,iDA0BXC,EAAAA,aAAYb,KAAA,CAAC,yBAaba,EAAAA,aAAYb,KAAA,CAAC,WA2DlBnC,EA3IA,GCnBAiD,EAAA,WAGA,SAAAA,KAIiD,2BAJhDC,EAAAA,SAAQf,KAAA,CAAC,CACNgB,aAAc,CAACnD,GACfoD,QAAS,CAACpD,OAEmCiD,EAPjD","sourcesContent":["import {\n    AfterViewInit,\n    Directive,\n    ElementRef,\n    forwardRef,\n    HostListener,\n    Inject,\n    OnDestroy,\n    Renderer2,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\n\n/*\n * This is a barebones contenteditable {@link ControlValueAccessor} allowing you to use\n * Angular forms with native contenteditable HTML. For security reasons you might want\n * to consider sanitizing pasted/dropped content before using it. Also make sure that\n * you do not set any dangerous content as control value yourself, because directive\n * just outputs control value as-is.\n */\n@Directive({\n    selector:\n        '[contenteditable][formControlName], [contenteditable][formControl], [contenteditable][ngModel]',\n    providers: [\n        {\n            provide: NG_VALUE_ACCESSOR,\n            useExisting: forwardRef(() => ContenteditableValueAccessor),\n            multi: true,\n        },\n    ],\n})\nexport class ContenteditableValueAccessor\n    implements ControlValueAccessor, AfterViewInit, OnDestroy {\n    /*\n     * MutationObserver IE11 fallback (as opposed to input event for modern browsers).\n     * When mutation removes a tag, i.e. delete is pressed on the last remaining character\n     * inside a tag â callback is triggered before the DOM is actually changed, therefore\n     * setTimeout is used\n     */\n    private observer = new MutationObserver(() => {\n        setTimeout(() => {\n            this.onChange(\n                ContenteditableValueAccessor.processValue(\n                    this.elementRef.nativeElement.innerHTML,\n                ),\n            );\n        });\n    });\n\n    /*\n     * onTouch callback that marks control as touched and allows FormHooks use\n     */\n    private onTouched = () => {};\n\n    /*\n     * onChange callback that writes value to control and allows FormHooks use\n     */\n    private onChange: (value: string) => void = () => {};\n\n    constructor(\n        @Inject(ElementRef) private readonly elementRef: ElementRef,\n        @Inject(Renderer2) private readonly renderer: Renderer2,\n    ) {}\n\n    /*\n     * To support IE11 MutationObserver is used to monitor changes to the content\n     */\n    ngAfterViewInit() {\n        this.observer.observe(this.elementRef.nativeElement, {\n            characterData: true,\n            childList: true,\n            subtree: true,\n        });\n    }\n\n    /*\n     * Disconnect MutationObserver IE11 fallback on destroy\n     */\n    ngOnDestroy() {\n        this.observer.disconnect();\n    }\n\n    /*\n     * Listen to input events to write innerHTML value into control,\n     * also disconnect MutationObserver as it is not needed if this\n     * event works in current browser\n     */\n    @HostListener('input')\n    onInput() {\n        this.observer.disconnect();\n        this.onChange(\n            ContenteditableValueAccessor.processValue(\n                this.elementRef.nativeElement.innerHTML,\n            ),\n        );\n    }\n\n    /*\n     * Listen to blur event to mark control as touched\n     */\n    @HostListener('blur')\n    onBlur() {\n        this.onTouched();\n    }\n\n    /*\n     * Reacts to external change\n     *\n     * @see {@link ControlValueAccessor#writeValue}\n     */\n    writeValue(value: string | null) {\n        this.renderer.setProperty(\n            this.elementRef.nativeElement,\n            'innerHTML',\n            ContenteditableValueAccessor.processValue(value),\n        );\n    }\n\n    /*\n     * Registers onChange callback\n     *\n     * @see {@link ControlValueAccessor#registerOnChange}\n     */\n    registerOnChange(onChange: (value: string) => void) {\n        this.onChange = onChange;\n    }\n\n    /*\n     * Registers onTouch callback\n     *\n     * @see {@link ControlValueAccessor#registerOnTouched}\n     */\n    registerOnTouched(onTouched: () => void) {\n        this.onTouched = onTouched;\n    }\n\n    /*\n     * Sets disabled state by setting contenteditable attribute to true/false\n     *\n     * @see {@link ControlValueAccessor#setDisabledState}\n     */\n    setDisabledState(disabled: boolean) {\n        this.renderer.setAttribute(\n            this.elementRef.nativeElement,\n            'contenteditable',\n            String(!disabled),\n        );\n    }\n\n    /*\n     * null and other falsy control values are treated as empty string to\n     * prevent IE11 outputting 'null', also single <br> is replaced with empty\n     * string when passed to the control\n     */\n    private static processValue(value: string | null): string {\n        const processed = value || '';\n\n        return processed.trim() === '<br>' ? '' : processed;\n    }\n}\n","import {NgModule} from '@angular/core';\nimport {ContenteditableValueAccessor} from './contenteditable-value-accessor';\n\n@NgModule({\n    declarations: [ContenteditableValueAccessor],\n    exports: [ContenteditableValueAccessor],\n})\nexport class ContenteditableValueAccessorModule {}\n"]}